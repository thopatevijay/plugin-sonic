{"version":3,"sources":["../src/actions/transferToken/transferToken.ts","../src/index.ts"],"sourcesContent":["import {\n    Content,\n    elizaLogger,\n    ModelClass,\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\nimport { composeContext, generateObjectDeprecated } from \"@elizaos/core\";\nimport { ethers } from \"ethers\";\n\nconst transferTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n\nExample response:\n\\`\\`\\`json\n{\n    \"recipient\": \"0x5C951583CEb79828b1fAB7257FE497A9Dc5896e6\",\n    \"amount\": \"1.5\",\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nExtract the following information about the requested token transfer:\n- Recipient address (Sonic wallet address)\n- Amount to transfer\n- Token contract address (null for native SONIC transfers, Sonic native token is \"S\")\n\nRespond with a JSON markdown block containing only the extracted values.`;\n\nasync function transferSimpleToken(\n    runtime: IAgentRuntime,\n    recipient: string,\n    amount: string\n): Promise<string | undefined> {\n\n    const DEFAULT_SONIC_RPC_URL = \"https://rpc.blaze.soniclabs.com\";\n    const sonicRPCUrl = runtime.getSetting(\"SONIC_RPC_URL\") as string || DEFAULT_SONIC_RPC_URL;\n    const walletPrivateKey = runtime.getSetting(\"SONIC_WALLET_PRIVATE_KEY\") as string;\n    const provider = new ethers.JsonRpcProvider(sonicRPCUrl);\n    const wallet = new ethers.Wallet(walletPrivateKey, provider);\n\n    const recipientAddress = recipient;\n    const amountToTransfer = ethers.parseEther(amount);\n\n    try {\n        // create txn object\n        const txn = {\n            to: recipientAddress,\n            value: amountToTransfer,\n            gasLimit: 21000,\n        }\n\n        // send the transaction\n        const tx = await wallet.sendTransaction(txn);\n        elizaLogger.info(\"Transaction sent:\", tx);\n\n        // wait for the transaction to be mined\n        const receipt = await tx.wait();\n\n        elizaLogger.info(\"Transaction successful:\", receipt);\n        return receipt?.hash ?? \"\";\n    } catch (error) {\n        elizaLogger.error(\"Error transferring token\", error);\n        throw error;\n    }\n}\n\nexport interface TransferContent extends Content {\n    recipient: string;\n    amount: string | number;\n}\n\nfunction isTransferContent(\n    _runtime: IAgentRuntime,\n    content: unknown\n): content is TransferContent {\n    return (\n        typeof (content as TransferContent).recipient === \"string\" &&\n        (typeof (content as TransferContent).amount === \"string\" ||\n            typeof (content as TransferContent).amount === \"number\")\n    );\n}\n\nexport const transferToken: Action = {\n    name: \"TRANSFER_TOKEN\",\n    description: \"Transfer SONIC token to a specific address\",\n    similes: [\"TRANSFER_TOKENS\", \"SEND_TOKENS\", \"SEND_TOKEN\", \"SEND_TOKENS_TO_ADDRESS\"],\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        elizaLogger.info(\"Validating transfer token action\");\n        return true;\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.info(\"Transferring token\");\n\n        if (!state) {\n            state = (await runtime.composeState(message)) as State;\n        } else {\n            state = await runtime.updateRecentMessageState(state);\n        }\n\n        const transferContext = composeContext({\n            state,\n            template: transferTemplate,\n        });\n\n        elizaLogger.info(\"Transfer context:\", transferContext);\n\n        const content = await generateObjectDeprecated({\n            runtime,\n            context: transferContext,\n            modelClass: ModelClass.LARGE,\n        });\n\n        elizaLogger.info(\"Transfer content:\", content);\n\n        // Validate transfer content\n        if (!isTransferContent(runtime, content)) {\n            elizaLogger.error(\"Invalid content for TRANSFER_TOKEN action.\");\n            if (callback) {\n                callback({\n                    text: \"Unable to process transfer request. Invalid content provided.\",\n                    content: { error: \"Invalid transfer content\" },\n                });\n            }\n            return false;\n        }\n\n        try {\n            const txnHash = await transferSimpleToken(\n                runtime,\n                content.recipient,\n                content.amount.toString(),\n            );\n\n            if (!txnHash) {\n                elizaLogger.error(\"Error transferring token\");\n                if (callback) {\n                    callback({\n                        success: false,\n                        text: `Error transferring token`,\n                        content: { error: \"Error transferring token\" },\n                    });\n                }\n                return false;\n            }\n\n            if (callback) {\n                callback({\n                    text: `Successfully transferred ${content.amount} to ${content.recipient} \\nTransaction: ${txnHash}`,\n                    content: {\n                        success: true,\n                        signature: txnHash,\n                        amount: content.amount,\n                        recipient: content.recipient,\n                    },\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error transferring token\", error);\n            if (callback) {\n                callback({\n                    text: `Error transferring token: ${error}`,\n                    content: { error: error },\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Transfer 0.1 S token to 0x5C951583CEb79828b1fAB7257FE497A9Dc5896e6\",\n                    action: \"TRANSFER_TOKEN\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I want to transfer 1 SONIC token to 0x5C951583CEb79828b1fAB7257FE497A9Dc5896e6\",\n                    action: \"TRANSFER_TOKEN\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Successfully sent 0.1 S token to 0x5C951583CEb79828b1fAB7257FE497A9Dc5896e6\",\n                },\n            },\n        ],\n    ],\n} as Action;\n","import type { Plugin } from \"@elizaos/core\";\nimport { transferToken } from \"./actions/transferToken/transferToken\";\n// interface Plugin {\n//     actions?: Action[];\n//     evaluators?: Evaluator[];\n//     services?: Service[];\n//     providers?: Provider[];\n//     initialize?(runtime: AgentRuntime): Promise<void>;\n//   }\n\nexport const sonicPlugin: Plugin = {\n    name: \"sonic\",\n    description: \"Sonic blockchain plugin for ElizaOS\",\n    actions: [\n        transferToken,\n    ],\n    clients: [],\n    adapters: [],\n    providers: [],\n};\n\nexport default sonicPlugin;"],"mappings":"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","names":[]}